# Project Overview
The goal of this project is to build a custom viral Kraken2 database that is capable of identifying plant viruses present in plant metagenomic data. When compared to a publically avaiable viral Kraken2 database. 

In order to achieve this goal, the project follows the process incorporating both Linux and R methods to generate Sankey plots and Phylogenetic trees for samples obtained from the Virginia Tech Plant Disease Clinic:
<img width="590" height="431" alt="Screenshot 2025-12-04 at 10 38 54 AM" src="https://github.com/user-attachments/assets/2a364d99-1941-484e-9d98-1d9b585123ba" />
 
# Kraken2 Custom Database Building
The Kraken2 custom database used for this pipeline was generated by collecting all complete and partially complete viral sequences from known plant-infecting viral families from NCBI using the NCBI datasets Conda package. CheckV was run on both the complete sequences and partially complete sequences to determine the completeness score of the partially complete sequences. Any partially complete sequence that did not fall within a specified range of the average sequence length of the complete sequences belonging to each plant viral family were removed from the database. Any partially complete sequence that had a completeness percentage below 30% was also removed from the database (30% was used based on CheckV stating any sequence below 30% complete is considered low-quality). To remove any presence of plant DNA within the viral reference sequences, a BLAST was run on both the complete and partially complete sequences against a BLAST DB of only plant genomes. Any viral sequence that has a positive hit against the plant DB was removed from the Kraken2 custom database. After sequence filtering, the resulting sequences were built into a Kraken 2 database using the Kraken 2 Conda package (specifically the k2 wrapper commands as well as kraken2-build):

```
k2 download-taxonomy --db DB_NAME

for file in PATH/TO/REFERENCE/SEQUENCES/*.fna; do
    echo "Adding $file..."
    kraken2-build --add-to-library "$file" --db DB_NAME
done

k2 build --db DB_NAME
k2 clean --db DB_NAME
```

# Conda Environment Setup
Create the conda environment:
```
  module load Miniconda3
  conda env create -f environment.yml -n indiv_prod_mg
```

# Download Repository
```
git clone --no-checkout https://github.com/mitchellgercken/I2GDS_Project/
cd I2GDS_Project/
git sparse-checkout init --cone
git sparse-checkout set repository
git checkout
cd repository
```

# Linux Script
The linux script below goes through the steps of classifying the mNGS data with the custom Kraken2 database (Standard viral database classification not shown). Moving into extracting the reads from the mNGS samples of the top 3 most abundant viruses (this step ensures the inclusion of dual infection if present). Lastly, the script run SPAdes to assemble all the reads from the top 3 most abundant viruses for each sample (if SPAdes assembly fails for one sample/taxid it will continue the loop; an issue I kept running into). The script does not show the process of running MAFFT on the assembled contigs and a IQtree using the reference sequences belonging to the same species as the virus detected in each sample. The resulting tree file, sample metadata, and taxonomic lineage files are used in the R script.

<details>
  <summary>Click to expand code</summary>
  
```

```
</details>

**To run script (in repository directory)**
```
sbatch scripts/linux_script.sh
```
**Expected outputs located in: /projects/intro2gds/I2GDS2025/G4_Viruses/mitchell/individual_project/expected_outputs**

# Sankey Plot Comparison
Sankey plots were generated from the Kraken2 report file from the Kraken2 classification command ran in the Linux script (this process is done manually outside of the linux script, as user verification that Kraken2 worked correctly prior to running MAFFT and IQtree). The sankey plots were created using the Pavian Shiny App Webinterface ([https://fbreitwieser.shinyapps.io/pavian/)](https://fbreitwieser.shinyapps.io/pavian/). The sankey plots from the Kraken2 custom database and the Kraken2 viral RefSeq databases are shown below for sample 24_557:

**Viral RefSeq Database**

<img width="722" height="381" alt="Screenshot 2025-12-16 at 12 24 43 PM" src="https://github.com/user-attachments/assets/f1a5c9e3-cbd9-4822-a18a-0e07a58b0639" />

**Custom Database**

<img width="722" height="381" alt="Screenshot 2025-12-16 at 12 25 11 PM" src="https://github.com/user-attachments/assets/835fec54-7f21-4539-99c0-697583cb8e40" />

# R Script
**It is important to note all R script was run in RStudio and was not tested on VT ARC**
The R script below goes through the process of generating a phylogenetic tree visualization of an IQtree consensus tree with 1000 tree replicates. The tree is generated with ggtree and dyprl primarily. The script takes an input tree file, input metadata on the sample of interest (includes geographic location, host organism, virus name, etc.), and a taxonomic lineage file for all viral species used in the Kraken 2 custom database. The metadata and taxonomic lineage file were generated with the NCBI Datasets Conda package (Not shown in the scripts). Tree generation is used as a validation step to ensure Kraken2 was correct with the classification. The resulting tree for sample 24_557 is shown below:

<details>
  <summary>Click to expand code</summary>
  
```
# Required Libraries
library(dplyr)
library(ggtree)
library(ggplot2)
library(treeio)

# Set input directory (location of all input files) - Should be changed if necessary
setwd("/projects/intro2gds/I2GDS2025/G4_Viruses/mitchell/individual_project/inputs")

# Set output directory variable for saving
indir <- "PATH/TO/DESIRED/OUTPUT"

# Taxonomic lineage input file
tax <- read.csv("tax_map.csv", header = T, sep = ",")

# Sample metadata input file
metadata <- read.delim("sequence_info.tsv", sep = "\t", stringsAsFactors = FALSE)

# Tree file input
contree_24557 <- read.tree("24-557_aln.fna.contree")

# Tree input variable for each sample along with sample name
trees <- list(
   "24-557 (Host: Mum)" = contree_24557)

# Correct tip label naming on a sample-by-sample process
extras_list <- list(
  "24-557 (Host: Mum)" = data.frame(
    accession_tips = c("Chrysanthemum", "Carlavirus"),
    accession_species = c(
      "24-557 (Host: Mum) - Chrysanthemum virus B contig",
      "24-557 (Host: Mum) - Chrysanthemum virus R contig"
    ),
    stringsAsFactors = FALSE
  )
#  Add second sample if necessary
)


# Storage for plots
plots <- list()

# Set sample_id variable
sample_ids <- c("24-557") # Add more samples as necessary

# Build sample_id bolding pattern (Sample1|Sample2|Sample3|etc.)
bold_pattern <- paste(sample_ids, collapse = "|")

# Modify tip labels/plot trees for each sample in trees list + extras_list
for (sample_id in names(trees)) {

  contree <- trees[[sample_id]]

  # Extract tree tip labels
  tip_labels <- contree$tip.label
  tip_labels <- sub("^([A-Z]{1,4}_?[0-9]+\\.[0-9]+).*", "\\1", tip_labels) # Strips tip label down to only accession number
  accession_tips <- grep("^[A-Z]{1,4}_?[0-9]+\\.[0-9]+$", tip_labels, value = TRUE) # Sets only accession number tips (reference genome related tips) to a separate variable for easier editing

  # Filter tip labels and add species information from taxonomic lineage file
  filtered_tax <- tax %>%
    filter(Accession %in% accession_tips) %>%
    transmute(accession_species = paste(Accession, Species.name, sep = " ")) # Adds species information to accession numbers that are present in the taxonomic lineage file "tax"

  # Sort updated tip labels by species name
  filtered_tax_sorted <- filtered_tax %>% arrange(accession_species)

  # Prepare tip labels to combine with the new sample tip labels (i.e., Chrysanthemum > 24-557 (Host: Mum) - Chrysanthemum virus B contig)
  accession_tips_df <- as.data.frame(sort(accession_tips))
  tip_df <- bind_cols(accession_tips_df, filtered_tax_sorted) %>%
    rename(accession_tips = 1)

  # Select the correct sample tip labels for each sample
  extras_df <- extras_list[[sample_id]]

  # Add Geographic location to each accession tip label + species resulting in: AccessionNumber Species (Geographic location)
  other_df <- tip_df %>% rename(Accession = accession_tips)
  combined_df <- left_join(other_df, metadata, by = "Accession") %>%
    mutate(
      formatted_location = gsub(":(\\S)", ": \\1", `Geographic.Location`),
      location_parens = ifelse(is.na(formatted_location) | formatted_location == "",
                               "",
                               paste0("(", formatted_location, ")")),
      Metadata_Combined = paste(`accession_species`, location_parens, sep = " ")
    )
  
  # Prepare tip_df to be used to rename the original tip labels with the newly formatted tip labels
  tip_df <- bind_cols(tip_df$accession_tips, combined_df$Metadata_Combined) %>%
    rename(accession_tips = ...1,
           accession_species = ...2)
  # Adds the sample tip labels which are specified prior to the function (i.e., Chrysanthemum > 24-557 (Host: Mum) - Chrysanthemum virus B contig)
  full_df <- bind_rows(tip_df, extras_df)

  # Rename tree tip labels with the newly formatted tip labels
  contree <- rename_taxa(contree, full_df, key = "accession_tips", value = "accession_species")

  # Plot the tree for tree data
  contree_plot <- ggtree(contree, branch.length = "none")
  
  # Add tip label bolding if the sample has a specified sample ID within the tip labels (sample related tips will be easier to see for comparison to reference genomes)
  contree_data <- contree_plot$data %>%
    mutate(label_bold = ifelse(grepl(bold_pattern, label), "bold", "plain"))

  # Plot consensus tree data with bolding and bootstrap values by circles of varying sizes
  p <- ggtree(contree_data) +
    geom_tiplab(aes(label = label, fontface = label_bold), align = TRUE, size = 5) +
    xlim(0, 30) +
    labs(title = paste("Phylogenetic Tree: Sample", sample_id)) +
    geom_point(
      data = subset(contree_plot$data, !is.na(label) & isTip == FALSE),
      aes(x = x, y = y, size = as.numeric(label)),
      color = "steelblue",
      alpha = 0.6
    ) +
    scale_size_continuous(name = "Bootstrap", range = c(1, 6)) +
    theme(legend.position = c(0.80, 0.5))

  # Store plot for current sample_id
  plots[[sample_id]] <- p
  
  # Save current plot as PDF (the file usually has incorrect formatting due to how ggtree displays/saves plots; it is best to print the plot, view it in full screen for the image to resize, then take a screenshot to save it - I was unable to find a fix for this issue)
  ggsave(
    filename = file.path(indir, paste0("phylo_tree-", sample_id, ".pdf")),
    plot = p,
    width = 10, height = 10, dpi = 300,
    bg = "white"
   )
}

# Display first sample plot
print(plots[[1]])
```
</details>

<img width="1162" height="725" alt="Screenshot 2025-12-16 at 1 05 58 PM" src="https://github.com/user-attachments/assets/4fe2a532-7a07-4919-90d9-726430ad85a5" />

# Results
Using information from both the sankey plots generated using both databases as well as the tree generated for the same sample. The sankey plot from the custom database indicates that Kraken2 has less false positives when ran with a database requiring a few more steps of refinement than compared to the standard viral database. The sankey plot of the custom database does not have the occurrance of the *Orthotospovirus capsicimaculaflavi* virus, which when a SPAdes assembly was ran on the resulting reads, a contig of 500bp revealed by BLAST as plant chloroplast results. This major difference between the two databases reinforced the plant contamination step taken prior to building the custom Kraken2 viral database. The standard viral database includes a contaminated RefSeq genome that continuously resulted in a large false positive. This negatively impacted the use of mNGS data for viral plant identification, which is resolved with the use of the custom Kraken2 database used in this pipeline. The tree visualization from R validates that Kraken2 made a correct classification when identifying both Chrysanthemum virus B and Chrysanthemum virus R in sample 24_557. The classification done with the custom database is also a lot more clear as to what is primarily present in the sample when compared to the standard viral database.

# Notes to myself
One large issue I find with my coding and script writing is to more frequently use comments in my code as well as staying better organized with my folders and the locations of scripts/inputs/outputs. I did not realize how much I struggled with this before taking this course.
The other issue I find with my coding is writing scripts in a sample to sample basis rather than a loop to at the start. If I began writing scripts with loops in mind, I would save myself a lot of time converting a non-loop-based script into a loop-based script.
